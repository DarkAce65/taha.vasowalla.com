<!DOCTYPE html>
<html>
	<head>
		<title>GLSL Shaders</title>
		<link rel="shortcut icon" href="img/icons/chip.png"/>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="theme-color" content="black">
		<meta name="msapplication-navbutton-color" content="black">
		<link rel="stylesheet" type="text/css" href="bower_components/bootstrap/dist/css/bootstrap.min.css"/>
		<link rel="stylesheet" type="text/css" href="bower_components/fontawesome/css/font-awesome.min.css"/>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
		<script src="bower_components/threejs/build/three.js"></script>
		<script src="lib/GSAP/TweenLite.min.js"></script>
		<script src="lib/GSAP/easing/EasePack.min.js"></script>
		<script src="lib/THREE.Controls/TrackballControls.js"></script>
		<style type="text/css">
			html, body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				overflow: hidden;
			}

			#controls {
				position: fixed;
				top: 5px;
				right: 5px;
				text-align: right;
			}

			.dropdown-menu > li > a, .dropdown-menu {
				background-color: #d9534f;
				color: white;
			}

			.dropdown-menu > li > a:focus, .dropdown-menu > li > a:hover {
				background-color: #c9302c;
				color: white;
				text-decoration: none;
			}
		</style>
	</head>
	<body>
		<div id="controls">
			<div class="btn-group">
				<button type="button" class="btn btn-danger dropdown-toggle" data-toggle="dropdown">
					<i class="fa fa-fw fa-video-camera"></i> Camera <span class="caret"></span>
				</button>
				<ul id="cubeDropdown" class="dropdown-menu pull-right">
					<li><a href="javascript:void(0)" onclick="setCamera('Overview')">Overview</a></li>
				</ul>
			</div>
		</div>
		<div id="rendererContainer"></div>
		<script id="staticVertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;

			void main() {
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<script id="matrixFragmentShader" type="x-shader/x-fragment">
			// Author @patriciogv - 2015
			// http://patriciogonzalezvivo.com

			uniform float u_time;
			uniform float u_speed;
			uniform float u_rows;

			varying vec2 vUv;

			float random(in float x) {
				return fract(sin(x) * 43758.5453);
			}

			float random(in vec2 st) {
				return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
			}

			float randomChar(in vec2 outer, in vec2 inner) {
				vec2 margin = vec2(0.2, 0.05);
				float seed = 23.0;
				vec2 borders = step(margin, inner) * step(margin, 1.0 - inner);
				return step(0.5, random(outer * seed + floor(inner * 3.0))) * borders.x * borders.y;
			}

			vec3 matrix(in vec2 st) {
				vec2 ipos = floor(st * u_rows) + vec2(1.0, 0);

				ipos += vec2(0, floor(u_time * u_speed * random(ipos.x)));

				vec2 fpos = fract(st * u_rows);
				vec2 center = 0.5 - fpos;

				float pct = random(ipos);
				float glowamount = (1.0 - dot(center, center) * 3.0);

				return vec3(randomChar(ipos, fpos) * pct * glowamount) * vec3(0, 1.0, 0);
			}

			void main() {
				gl_FragColor = vec4(matrix(vUv), 1.0);
			}
		</script>
		<script id="noiseFragmentShader" type="x-shader/x-fragment">
			uniform float u_time;
			uniform vec2 u_resolution;

			varying vec2 vUv;

			// Credit for Perlin noise function goes to https://github.com/ashima/webgl-noise

			vec3 mod289(vec3 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 mod289(vec4 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 permute(vec4 x) {
				return mod289(((x * 34.0) + 1.0) * x);
			}

			vec4 taylorInvSqrt(vec4 r) {
				return 1.79284291400159 - 0.85373472095314 * r;
			}

			float snoise(vec3 v) {
				const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
				const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

				// First corner
				vec3 i  = floor(v + dot(v, C.yyy));
				vec3 x0 =   v - i + dot(i, C.xxx);

				// Other corners
				vec3 g = step(x0.yzx, x0.xyz);
				vec3 l = 1.0 - g;
				vec3 i1 = min(g.xyz, l.zxy);
				vec3 i2 = max(g.xyz, l.zxy);

				//   x0 = x0 - 0.0 + 0.0 * C.xxx;
				//   x1 = x0 - i1  + 1.0 * C.xxx;
				//   x2 = x0 - i2  + 2.0 * C.xxx;
				//   x3 = x0 - 1.0 + 3.0 * C.xxx;
				vec3 x1 = x0 - i1 + C.xxx;
				vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
				vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

				// Permutations
				i = mod289(i);
				vec4 p = permute(permute(permute(
					  i.z + vec4(0.0, i1.z, i2.z, 1.0))
					+ i.y + vec4(0.0, i1.y, i2.y, 1.0))
					+ i.x + vec4(0.0, i1.x, i2.x, 1.0));

					// Gradients: 7x7 points over a square, mapped onto an octahedron.
					// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
					float n_ = 0.142857142857; // 1.0/7.0
					vec3  ns = n_ * D.wyz - D.xzx;

					vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

					vec4 x_ = floor(j * ns.z);
					vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)

					vec4 x = x_ * ns.x + ns.yyyy;
					vec4 y = y_ * ns.x + ns.yyyy;
					vec4 h = 1.0 - abs(x) - abs(y);

					vec4 b0 = vec4(x.xy, y.xy);
					vec4 b1 = vec4(x.zw, y.zw);

					//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
					//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
					vec4 s0 = floor(b0) * 2.0 + 1.0;
					vec4 s1 = floor(b1) * 2.0 + 1.0;
					vec4 sh = -step(h, vec4(0.0));

					vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;
					vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;

					vec3 p0 = vec3(a0.xy, h.x);
					vec3 p1 = vec3(a0.zw, h.y);
					vec3 p2 = vec3(a1.xy, h.z);
					vec3 p3 = vec3(a1.zw, h.w);

					//Normalise gradients
					vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
					p0 *= norm.x;
					p1 *= norm.y;
					p2 *= norm.z;
					p3 *= norm.w;

					// Mix final noise value
					vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
					m = m * m;
					return 42.0 * dot(m * m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
				}

			void main() {
				vec2 st = vUv * 5.0;
				vec3 color = vec3(0.0);
				color.r = snoise(vec3(st, u_time / 8.0));
				color.g = snoise(vec3(st * 0.5, u_time / 6.0));
				color.b = snoise(vec3(st * 0.25, u_time / 4.0));

				gl_FragColor = vec4(color, 1.0);
			}
		</script>
		<script id="transparentFragmentShader" type="x-shader/x-fragment">
			uniform float u_time;
			uniform vec2 u_resolution;

			varying vec2 vUv;

			mat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);

			void main() {
				vec2 st = vUv * 2.0 - 1.0;
				vec3 color = vec3(0.0);

				color = yuv2rgb * vec3(0.5, st.x, st.y);

				gl_FragColor = vec4(color, smoothstep(0.2, 0.8, distance(vec2(st.x, st.y), vec2(0.0))));
			}
		</script>
		<script type="text/javascript">
			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			var uniforms = {
				u_time: {type: "f", value: 0},
				u_resolution: {type: "v2", value: new THREE.Vector2},
				u_rows: {type: "f", value: 40.0},
				u_speed: {type: "f", value: 4.0}
			};

			function shaderConfig(vertex, fragment) {
				return {
					"uniforms": uniforms,
					"vertexShader": document.getElementById(vertex).textContent,
					"fragmentShader": document.getElementById(fragment).textContent
				}
			}

			var factor = window.innerWidth < 768 ? 1.5 : 1;

			var clock = new THREE.Clock();
			var scene = new THREE.Scene();
			var renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
			$("#rendererContainer").append(renderer.domElement);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x000000); // 0xD5DDFF - Gray
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.shadowMap.enabled = true;

			var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 10000);
			camera.position.set(0, 0, 100);
			scene.add(camera);
			var controls = new THREE.TrackballControls(camera, renderer.domElement);
			camera.lookAt(scene.position);

			var cubes = {};
			var cubeGeometry = new THREE.BoxGeometry(70, 70, 70);

			var material = new THREE.ShaderMaterial(shaderConfig("staticVertexShader", "matrixFragmentShader"));
			material.side = THREE.DoubleSide;
			cubes["Matrix"] = new THREE.Mesh(cubeGeometry, material);

			var material = new THREE.ShaderMaterial(shaderConfig("staticVertexShader", "noiseFragmentShader"));
			material.side = THREE.DoubleSide;
			cubes["Noise"] = new THREE.Mesh(cubeGeometry, material);

			material = new THREE.ShaderMaterial(shaderConfig("staticVertexShader", "transparentFragmentShader"));
			material.side = THREE.FrontSide;
			material.transparent = true;
			var mesh = new THREE.Mesh(cubeGeometry, material);
			mesh.renderOrder = 2;

			material = new THREE.ShaderMaterial(shaderConfig("staticVertexShader", "transparentFragmentShader"));
			material.side = THREE.BackSide;
			material.transparent = true;
			var transparentCube = new THREE.Object3D();
			transparentCube.add(new THREE.Mesh(cubeGeometry, material));
			transparentCube.add(mesh);
			cubes["Transparent"] = transparentCube;

			var cubeKeys = Object.keys(cubes);
			var viewportBounds = {"maxX": 0, "maxY": 0};
			for(var i = 0; i < cubeKeys.length; i++) {
				var angle = 2 * Math.PI * i / cubeKeys.length;
				var c = 100 * Math.cos(angle);
				var s = 100 * Math.sin(angle);
				cubes[cubeKeys[i]].position.set(c, s, 0);
				viewportBounds.maxX = Math.max(viewportBounds.maxX, Math.abs(c));
				viewportBounds.maxY = Math.max(viewportBounds.maxY, Math.abs(s));
				scene.add(cubes[cubeKeys[i]]);
				$("#cubeDropdown").append('<li><a href="javascript:void(0)" onclick="setCamera(\'' + cubeKeys[i] + '\')">' + cubeKeys[i] + ' Cube</a></li>');
			}
			viewportBounds.maxX += 50;
			viewportBounds.maxY += 50;

			function setCamera(position) {
				var x = 0, y = 0, z = 0,
					uy = 0, uz = 0,
					tx = 0, ty = 0, tz = 0;

				if(cubeKeys.indexOf(position) != -1) {
					tx = cubes[position].position.x;
					ty = cubes[position].position.y;
					x = tx + 100;
					y = ty - 180;
					z = 100;
					uz = 1;
				}
				else {
					x = 0;
					y = 0;
					uy = 1;
					if(viewportBounds.maxY / viewportBounds.maxX < camera.aspect) {
						z = viewportBounds.maxY / Math.tan(camera.fov * Math.PI / 360);
					}
					else {
						z = viewportBounds.maxX / Math.tan(camera.fov * Math.PI / 360) / camera.aspect;
					}
					z += 70 / 2;
					z /= factor;
				}

				x *= factor;
				y *= factor;
				z *= factor;

				TweenLite.to(camera.position, 2, {x: x, y: y, z: z, ease: Power2.easeInOut});
				TweenLite.to(controls.target, 2, {x: tx, y: ty, z: tz, ease: Power2.easeOut, onUpdate: function(){camera.lookAt(controls.target);}});
				TweenLite.to(camera.up, 1.75, {x: 0, y: uy, z: uz});
			}

			function render() {
				requestAnimFrame(render);
				renderer.render(scene, camera);
				controls.update();
				uniforms.u_time.value += clock.getDelta() * 3;
			}

			render();

			$(window).resize(function() {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				factor = 1;
				uniforms.u_rows.value = 40;
				if(window.innerWidth < 768) {
					factor = 1.5;
					uniforms.u_rows.value = 20;
				}
			});

			$(window).load(function() {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				if(window.innerWidth < 768) {
					uniforms.u_rows.value = 20;
				}
				setCamera("Overview");
			});
		</script>
	</body>
</html>