<!DOCTYPE html>
<html>
	<head>
		<title>Experimental</title>
		<link rel="shortcut icon" href="img/icons/TV.png"/>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="bower_components/bootstrap/dist/css/bootstrap.min.css"/>
		<link rel="stylesheet" type="text/css" href="bower_components/font-awesome/css/font-awesome.min.css"/>
		<link rel="stylesheet" type="text/css" href="bower_components/toastr/toastr.min.css"/>
		<script src="bower_components/jquery/dist/jquery.min.js"></script>
		<script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
		<script src="bower_components/three.js/build/three.js"></script>
		<script src="lib/GSAP/TweenMax.min.js"></script>
		<script src="lib/THREE.Controls/TrackballControls.js"></script>
		<script src="bower_components/toastr/toastr.min.js"></script>
		<style type="text/css">
			html, body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				overflow: hidden;
			}

			#controls {
				position: fixed;
				top: 5px;
				right: 5px;
				text-align: right;
			}

			.dropdown-menu > li > a, .dropdown-menu {
				background-color: #d9534f;
				color: white;
			}

			.dropdown-menu > li > a:focus, .dropdown-menu > li > a:hover {
				background-color: #c9302c;
				color: white;
				text-decoration: none;
			}
		</style>
	</head>
	<body>
		<div id="controls">
			<div class="btn-group">
				<button type="button" class="btn btn-danger dropdown-toggle" data-toggle="dropdown">
					<i class="fa fa-fw fa-video-camera"></i> Camera <span class="caret"></span>
				</button>
				<ul class="dropdown-menu pull-right">
					<li><a href="javascript:void(0)" onclick="setCamera('Overhead')">Overhead</a></li>
				</ul>
			</div>
		</div>
		<div id="rendererContainer"></div>
		<script id="vertexShader" type="x-shader/x-vertex">
			uniform float u_time;

			varying vec2 vUv;

			void main() {
				vUv = uv;

				vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<script id="bgFragmentShader" type="x-shader/x-fragment">
			#define PI 3.14159265359

			uniform float u_time;
			uniform vec2 u_resolution;
			uniform sampler2D u_textureMap;
			uniform float u_textureRatio;

			varying vec2 vUv;

			vec2 scaleTexture(vec2 texCoord) {
				float ratio = u_resolution.x / u_resolution.y;
				vec2 scale = vec2(1.0, 1.0);
				float ratioDelta = ratio - u_textureRatio;
				if(ratioDelta >= 0.0) {
					scale.y = 1.0 + ratioDelta;
				}
				else {
					scale.x = 1.0 - ratioDelta;
				}

				return texCoord / scale;
			}

			void main() {
				vec2 st = vUv;

				gl_FragColor = texture2D(u_textureMap, scaleTexture(st));
			}
		</script>
		<script id="rainFragmentShader" type="x-shader/x-fragment">
			#define PI 3.14159265359

			uniform float u_time;
			uniform vec2 u_resolution;
			uniform vec2 u_dropPosition;
			uniform sampler2D u_textureMap;
			uniform float u_textureRatio;

			varying vec2 vUv;

			vec2 scaleTexture(vec2 texCoord) {
				float ratio = u_resolution.x / u_resolution.y;
				vec2 scale = vec2(1.0, 1.0);
				float ratioDelta = ratio - u_textureRatio;
				if(ratioDelta >= 0.0) {
					scale.y = 1.0 + ratioDelta;
				}
				else {
					scale.x = 1.0 - ratioDelta;
				}

				return texCoord / scale;
			}

			vec2 makeNormalMap(in vec2 st) {
				st -= 0.5;
				st *= mat2(
					0.0, 1.0,
					-1.0, 0.0
				);
				st += 0.5;

				vec2 norm = st;

				norm.x = mix(norm.x, 0.5, smoothstep(0.68, 0.82, st.x));
				norm.y = mix(norm.y, 0.5, smoothstep(0.68, 0.82, st.x));

				norm -= 0.5;

				return norm.yx;
			}

			void main() {
				vec2 st = vUv;
				vec2 norm = makeNormalMap(st);
				norm.y *= -1.0;

				vec2 pos = vec2(u_dropPosition * (1.0 + norm));

				gl_FragColor = texture2D(u_textureMap, scaleTexture(pos));
			}
		</script>
		<script type="text/javascript">
			window.requestAnimFrame =
				window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					window.setTimeout(callback, 1000 / 60);
				};

			var factor = window.innerWidth < 768 ? 1.5 : 1;

			var loader = new THREE.TextureLoader();
			var clock = new THREE.Clock();
			var scene = new THREE.Scene();
			var renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
			$("#rendererContainer").append(renderer.domElement);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xD5DDFF);
			renderer.setPixelRatio(window.devicePixelRatio);

			var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 10000);
			camera.position.set(0, 0, 375);
			scene.add(camera);
			var controls = new THREE.TrackballControls(camera, renderer.domElement);
			camera.lookAt(scene.position);

			var uniforms = {
				u_time: {type: "f", value: 0},
				u_resolution: {type: "v2", value: new THREE.Vector2(150, 150)},
				u_textureMap: {type: "t", value: null},
				u_textureRatio: {type: "f", value: 1.0}
			};
			var material = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: document.getElementById("vertexShader").textContent,
				fragmentShader: document.getElementById("bgFragmentShader").textContent,
				side: THREE.DoubleSide
			});
			var objectGeometry = new THREE.PlaneGeometry(150, 150, 50, 50);
			var object = new THREE.Mesh(objectGeometry, material);
			scene.add(object);

			var rainUniforms = {
				u_time: {type: "f", value: 0},
				u_resolution: {type: "v2", value: new THREE.Vector2(150, 150)},
				u_dropPosition: {type: "v2", value: new THREE.Vector2(0.5, 0.5)},
				u_textureMap: {type: "t", value: null},
				u_textureRatio: {type: "f", value: 1.0}
			};
			material = new THREE.ShaderMaterial({
				uniforms: rainUniforms,
				vertexShader: document.getElementById("vertexShader").textContent,
				fragmentShader: document.getElementById("rainFragmentShader").textContent,
				side: THREE.DoubleSide
			});
			objectGeometry = new THREE.CircleGeometry(5, 64);
			rain = new THREE.Mesh(objectGeometry, material);
			scene.add(rain);
			rain.position.z++;

			function setCamera(position) {
				var x = 0, y = 0, z = 0,
					uy = 0, uz = 0,
					tx = 0, ty = 0, tz = 0;

				switch(position) {
					case "Overhead":
					default:
						x = 0;
						y = 0;
						z = 375;
						uy = 1;
						break;
				}

				x *= factor;
				y *= factor;
				z *= factor;

				TweenLite.to(camera.position, 2, {x: x, y: y, z: z, ease: Power2.easeInOut});
				TweenLite.to(controls.target, 2, {x: tx, y: ty, z: tz, ease: Power2.easeInOut, onUpdate: function(){camera.lookAt(controls.target);}});
				TweenLite.to(camera.up, 1.75, {x: 0, y: uy, z: uz});
			}

			function render() {
				requestAnimFrame(render);
				renderer.render(scene, camera);
				controls.update();

				var delta = clock.getDelta();
				uniforms.u_time.value += delta * 3;
				var ry = -uniforms.u_time.value * 10 % 140 + 70;
				var rx = 70 * Math.sin(Math.floor(uniforms.u_time.value * 10 / 140));
				rain.position.set(rx, ry, 1);
				rainUniforms.u_dropPosition.value.set(rx / 100 + 1, ry / 100 + 1);
			}

			loader.load("img/textures/texture-rain-fg.png", function(texture) {
				uniforms.u_textureRatio.value = texture.image.width / texture.image.height;
				uniforms.u_textureMap.value = texture;
				uniforms.u_textureMap.value.wrapS = THREE.RepeatWrapping;
				uniforms.u_textureMap.value.wrapT = THREE.RepeatWrapping;
				toastr.clear(lastToast);
			});

			toastr.options = {"positionClass": "toast-bottom-right", "showMethod": "slideDown", "hideMethod": "slideUp", "tapToDismiss": false};
			toastr.options.timeOut = 0;
			toastr.options.extendedTimeOut = 0;
			lastToast = toastr.info("Loading textures...");
			render();

			$(window).resize(function() {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				factor = window.innerWidth < 768 ? 1.5 : 1;
			});

			$(window).load(function() {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});
		</script>
	</body>
</html>